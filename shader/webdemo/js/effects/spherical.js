// Code by Jaume SÃ¡nchez 
// http://www.twitter.com/thespite @thespite

var sphere_vs = "void main() { gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );}";
var sphere_fs = "uniform vec2 resolution; uniform float noise; vec3 colors = vec3(4.1, 5.5, 0);";
sphere_fs +=  "float random(vec3 scale,float seed){return fract(sin(dot(gl_FragCoord.xyz+seed,scale))*43758.5453+seed);}";
sphere_fs += "void main() { vec3 color = vec3( 34. / 255. ); vec2 center = resolution * 0.5; float vignette = distance( center, gl_FragCoord.xy ) / resolution.x; vignette = colors.x - vignette * colors.y; float n = noise * ( .5 - random( vec3( 1. ), length( gl_FragCoord ) ) ); gl_FragColor = vec4( color * vec3( vignette ) + vec3( n ), 1. );}";

var sphere_vertexShader = "attribute vec4 tangent; uniform float time; uniform vec2 repeat; uniform float useNormal; uniform float useRim;";
sphere_vertexShader += "varying vec2 vUv; varying vec3 vTangent; varying vec3 vBinormal; varying vec3 vNormal; varying vec3 vEye; varying vec3 vU; varying vec2 vN;";
sphere_vertexShader += "void main() { vU = normalize( vec3( modelViewMatrix * vec4( position, 1.0 ) ) ); if( useNormal == 0. ) { vec3 n = normalize( normalMatrix * normal ); vec3 r = reflect( vU, n ); float m = 2.0 * sqrt( r.x * r.x + r.y * r.y + ( r.z + 1.0 ) * ( r.z+1.0 ) ); vN = vec2( r.x / m + 0.5,  r.y / m + 0.5 ); } else { vN = vec2( 0. ); } vUv = repeat * uv; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); vNormal = normalize( normalMatrix * normal ); if( useNormal == 1. ) { vTangent = normalize( normalMatrix * tangent.xyz ); vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w ); } else { vTangent = vec3( 0. ); vBinormal = vec3( 0. ); } if( useRim > 0. ) { vEye = ( modelViewMatrix * vec4( position, 1.0 ) ).xyz; } else { vEye = vec3( 0. ); } }";

var sphere_fragmentShader = "uniform float time; uniform float bump; uniform sampler2D tNormal; uniform sampler2D tMatCap;";
sphere_fragmentShader += "uniform float noise; uniform float useNormal; uniform float useRim; uniform float rimPower; uniform float useScreen; uniform float normalScale; uniform float normalRepeat;";
sphere_fragmentShader += "varying vec2 vUv; varying vec3 vTangent; varying vec3 vBinormal; varying vec3 vNormal; varying vec3 vEye; varying vec3 vU; varying vec2 vN;";	
sphere_fragmentShader += "float random(vec3 scale,float seed){return fract(sin(dot(gl_FragCoord.xyz+seed,scale))*43758.5453+seed);}";
sphere_fragmentShader += "void main() { vec3 finalNormal = vNormal; vec2 calculatedNormal = vN; if( useNormal == 1. ) { vec3 normalTex = texture2D( tNormal, vUv * normalRepeat ).xyz * 2.0 - 1.0; normalTex.xy *= normalScale; normalTex.y *= -1.; normalTex = normalize( normalTex ); mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) ); finalNormal = tsb * normalTex; vec3 r = reflect( vU, normalize( finalNormal ) ); float m = 2.0 * sqrt( r.x * r.x + r.y * r.y + ( r.z + 1.0 ) * ( r.z+1.0 ) ); calculatedNormal = vec2( r.x / m + 0.5,  r.y / m + 0.5 ); } vec3 base = texture2D( tMatCap, calculatedNormal ).rgb; if( useRim > 0. ) { float f = rimPower * abs( dot( vNormal, normalize( vEye ) ) ); f = useRim * ( 1. - smoothstep( 0.0, 1., f ) ); base += vec3( f ); } if( useScreen == 1. ) { base = vec3( 1. ) - ( vec3( 1. ) - base ) * ( vec3( 1. ) - base ); } base += noise * ( .5 - random( vec3( 1. ), length( gl_FragCoord ) ) ); gl_FragColor = vec4( base, 1. ); }";	